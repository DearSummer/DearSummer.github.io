---
title: 二进制减法的实现
tags:
  - CODE
abbrlink: '37270847'
date: 2019-05-04 16:52:48
---

{% asset_img beef684d6068ff82.jpg %}

<!-- more -->

------

[在这里](https://dearsummer.github.io/posts/8075ab0a/)，我们曾经实现了一个全加器，用于计算二进制的加法。

而有加法自然就会有减法。那么，减法又是怎么操作的呢？

首先，我们还是可以看看十进制的减法是怎么计算的。比如541-141，从左到右依次相减，这样就可以计算出来了，如同加法一样。但是，这里有个问题，那就是借位的问题。

不过实际上，借位的问题与进位的问题是一致的，我们同样可以利用减法位与借位位来构建一个新的电路结构，实现全减器的效果。

不过，一般来说，计算机使用了另一种方式去实现减法的效果，从而避免了设计一个新的电路的情况，那就是利用全加器去实现减法的效果。

那么怎么实现呢？

比如，我们可以这样
$$
\begin{split}&873-637=236\\=>& 999-637=362\\=>&362+1=363\\=>&363+873=1236\end{split}
$$
先使用当前位数的最大值减去被减数，这样就可以完美的避免了借位操作，然后，再将被减数与减速相加，多出来的那个位舍弃掉（也就是1236舍弃1，变成236），就可以实现相减的效果了。

是不是很奇妙，其实这个公式调整一下顺序可以变成这样
$$
\begin{split}&873-637+999+1-1000\\=&873+(-637+999)+1-1000\end{split}
$$
而在这里，999-637=362的操作中，这个362就被称之为补码。

所谓补码就是当前位的最大值减去当前位，比如2的补码就是7，对637求补码的操作实际上也就是每一位都是拿9去减去当前位就可以了。

而这样的操作在二进制中更是再简单不过了对吧？二进制当中的每一位都只有0与1，那么求补码也就是对当前位取反嘛（1的补码是0，0的补码是1，很简单就能算出来对吧:smile），因此，我们在这里，只要对输入的数每一位都使用反相器是不是就可以对其取反呢。

而加一操作就更简单了。我们还记得全加器有一个进位位吧，只要在个位的进位位置为1，那么自然而然就会达到加一的效果啦。

总之，使用这种操作就可以完美的实现了不用重新构造一个全新的电路就完成减法操作的目的了。