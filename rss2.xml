<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Just A Blog</title>
    <link>https://ShinyGX.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 10 Jan 2021 14:48:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>游戏AI-行为树</title>
      <link>https://ShinyGX.github.io/posts/cd3e3288/</link>
      <guid>https://ShinyGX.github.io/posts/cd3e3288/</guid>
      <pubDate>Sun, 10 Jan 2021 19:00:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;使用unity实现一个简单的行为树&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>使用unity实现一个简单的行为树<br><a id="more"></a></p><hr><h2 id="What-Is-Bahavior-Tree"><a href="#What-Is-Bahavior-Tree" class="headerlink" title="What Is Bahavior Tree"></a>What Is Bahavior Tree</h2><p>关于游戏的ai，使用行为树是一种比较简单的方式去操作ai行动逻辑的行为手段。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/cd3e3288/BT_Overview_Intro.png" title="ue4中的行为树"><p>如上图所示，为ue4当中的行为树的表现方式，从根节点出发，自上而下，自左往右进行行为的判断或者操作，当节点的行为进行完毕的时候，就会返回true or false，并将控制权转移到父节点，父节点会根据子节点的执行的结果来判断下一步的执行。</p><p>在这一颗树当中，可以看作是一个没有终止条件的Loop，不断的从root节点开始，遍历着这棵树的节点，再由子节点内的内容条件来判断下一步的操作，在层层逻辑的递进之下，形成了ai的一套树形的行为模式。</p><h2 id="Tree-Node"><a href="#Tree-Node" class="headerlink" title="Tree Node"></a>Tree Node</h2><p>行为树由各个树节点组成，在我看来行为树的节点大致可以分为三类</p><h3 id="Composite-Node"><a href="#Composite-Node" class="headerlink" title="Composite Node"></a>Composite Node</h3><p>第一类,复杂节点，最主要的作用就是驱动行为树的运行模式，比如，顺序执行子节点，随机执行子节点，顺序执行子节点直到子节点返回失败等等逻辑操作，成为行为树的驱动中心</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序调度，直到子节点调用失败为止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SequenceNode</span> : <span class="title">CompositeNode</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProcessResult <span class="title">Process</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (INode node <span class="keyword">in</span> nodes)</span><br><span class="line">        &#123;</span><br><span class="line">            ProcessResult result = node.Process();</span><br><span class="line">            <span class="keyword">if</span> (result == ProcessResult.Failed)</span><br><span class="line">                <span class="keyword">return</span> ProcessResult.Failed;</span><br><span class="line">            <span class="keyword">if</span> (result == ProcessResult.Running)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ProcessResult.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序调度，直到子节点调用成功为止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectorNode</span> : <span class="title">CompositeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProcessResult <span class="title">Process</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(INode node <span class="keyword">in</span> nodes)</span><br><span class="line">        &#123;</span><br><span class="line">            ProcessResult result = node.Process();</span><br><span class="line">            <span class="keyword">if</span> (result == ProcessResult.Success)</span><br><span class="line">                <span class="keyword">return</span> ProcessResult.Success;</span><br><span class="line">            <span class="keyword">if</span> (result == ProcessResult.Running)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ProcessResult.Failed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是两种比较典型的行为树节点，其实复杂节点作为行为树的逻辑驱动推断，可以根据ai的需求不断扩展，不过，个人感觉最终也是和程序运行一样，最终都是以<code>顺序执行</code>,<code>跳转</code>,<code>随机执行</code>,<code>并行</code>之类的方式来进行逻辑的操控</p><h3 id="Action-Node"><a href="#Action-Node" class="headerlink" title="Action Node"></a>Action Node</h3><p>第二类则是行为节点，在行为树当中，用于执行ai的操作的节点，包括不限于移动到某处，跳跃，是否离目标点距离x米之类的实际的行为判断与行为操作，在行为树当中是只能够作为叶子节点存在的节点。这种节点操作十分丰富，需要根据ai的实际操作需求来进行对应的行为节点的实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> ProcessResult <span class="title">ActionFunc</span>(<span class="params">TreeContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//行动节点，不允许拥有子节点，为行为树最终需要进行指向的操作，行为树唯一允许成为子节点的节点</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionNode</span> : <span class="title">BaseNode</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ActionNode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           maxChild = NodeChildLimit.NONE;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> NodeID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> INode <span class="title">Enter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProcessResult <span class="title">Process</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">if</span> (func != <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               ProcessResult result = func(<span class="keyword">this</span>.context);</span><br><span class="line">               <span class="keyword">if</span> (result == ProcessResult.Running)</span><br><span class="line">                   <span class="keyword">this</span>.context.EnterSubtree(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> ProcessResult.Failed;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> ActionFunc func &#123; <span class="keyword">set</span>; <span class="keyword">private</span> <span class="keyword">get</span>; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我看来，应该是一种类似这样的结构，对于外部的行为需求，只需要外部传入一个行为func，之后就会在ActionNode当中进行操作与执行。</p><h3 id="Decorator-Node"><a href="#Decorator-Node" class="headerlink" title="Decorator Node"></a>Decorator Node</h3><p>最后一类则是装饰节点，用于对节点的返回值进行修饰的操作的，比如取反。这类节点的具体用处就如同其名字一样。以便于我们更好的操作行为逻辑，就如同写代码会有出现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> has_key:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></p><p>这种情况那样，更加方便去操作行为树的行为结构</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对执行结果取反</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OppositeNode</span> : <span class="title">DecoratorNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProcessResult <span class="title">Process</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ProcessResult result = child.Process();</span><br><span class="line">        <span class="keyword">if</span> (result == ProcessResult.Success)</span><br><span class="line">            <span class="keyword">return</span> ProcessResult.Failed;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == ProcessResult.Failed)</span><br><span class="line">            <span class="keyword">return</span> ProcessResult.Success;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这三类行为节点的驱动下，就可以简单的对这棵树进行逻辑上的操作了，不断根据复杂节点的驱动形式去驱动这棵树的行为，最终使得ai得到了我们想要操作的样子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoUpdate</span>(<span class="params">INode node</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node.Enter();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ProcessResult result = node.Process();</span><br><span class="line">            <span class="keyword">if</span> (result == ProcessResult.Running)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.Leave();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作的逻辑大概也就是这样了。</p><h2 id="行为树的驱动方式"><a href="#行为树的驱动方式" class="headerlink" title="行为树的驱动方式"></a>行为树的驱动方式</h2><p>按照我上面所写的驱动方式，大概就是行为树当中的Tick-Driven形式了，这是一种最简单的行为树的形式，这种形式需要不断的从行为树的根节点进行出发，在一个（或者几个）Tick的时间内重新执行一遍行为树，当ai的行为进入了比如移动到某处之类的需要长时间停留在某一个状态上的操作的时候，就有可能会出现不断遍历这颗行为树的情况（但是因为无论如何最终都会走到移动到某处这个节点上的）</p><p>因此，为了应对这种情况，就出现了一种Even-Driven形式的行为树了，这种行为树需要当事件到达的时候才会对行为树的节点进行下一步的操作，那么就可以避免当行为树在操作一个耗时的行为的时候却进行了无意义的行为树遍历所造成的资源的损耗的问题了</p><p>同时，这种结构也需要支持中断操作，就比如当当前行为树执行攻击玩家的操作的时候，玩家闪现跑路了，这个时候就需要中断这个行为了。需要在这个行为的基础之上需要重新唤醒整颗行为树，让其从当前节点（或者从root节点）开始继续进行后续逻辑的判断</p><p>在ue4当中就为其提供了<code>patrol</code>与<code>waitEvent</code>节点来进行相对应的操作</p><h2 id="简单的行为树Demo"><a href="#简单的行为树Demo" class="headerlink" title="简单的行为树Demo"></a>简单的行为树Demo</h2><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/cd3e3288/bt.gif"><p><a href="https://github.com/ShinyGX/BehaviorTreeDemo" target="_blank" rel="noopener">简单的小框架</a></p>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/cd3e3288/#disqus_thread</comments>
    </item>
    
    <item>
      <title>实现一个@property</title>
      <link>https://ShinyGX.github.io/posts/b151bc1/</link>
      <guid>https://ShinyGX.github.io/posts/b151bc1/</guid>
      <pubDate>Sun, 03 Jan 2021 18:36:19 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==&quot; data-original=&quot;/posts/b151bc1/property.png&quot; title=&quot;property&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/b151bc1/property.png" title="property"><a id="more"></a><hr><p>正如一开始的图片所示，@property是一件十分之方便的工具，正如c#里面的get与set的语法糖似的，可以帮助我们快速的实现对象的约束，而不需要为其建立麻烦的getter与setter方法。</p><p>那么这个@property是一种怎么样的实现方式呢？</p><p>从语法上可以推测其实这是一种方法装饰器，本质上就是对这个方法进行一次加工与包装，使得其能够符合我们的使用意愿去进行操作。但是，其实@property还有一种操作方式那就是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.x = property(<span class="keyword">self</span>.__getter,<span class="keyword">self</span>.__setter,<span class="keyword">self</span>.__deleter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getter</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setter</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__deleter</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        del <span class="keyword">self</span>._x</span><br></pre></td></tr></table></figure><p>在为property对象分别写入了get，set，del方法之后，x也同样拥有了以上的属性，可以看出，虽然@property利用了装饰器的语法，但是实际上内部的操作并不是如同装饰器一般对函数进行包装的。</p><h2 id="property的实现原理"><a href="#property的实现原理" class="headerlink" title="@property的实现原理"></a>@property的实现原理</h2><p>从Python源码来看property的基本结构就是get，set，del三个方法和对应这三个方法的成员变量<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//property包含了get，set，del三个方法</span></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *prop_get;</span><br><span class="line">    PyObject *prop_set;</span><br><span class="line">    PyObject *prop_del;</span><br><span class="line">    PyObject *prop_doc;</span><br><span class="line">    int getter_doc;</span><br><span class="line">&#125; propertyobject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">static</span> PyMemberDef property_members[] = &#123;</span><br><span class="line">    &#123;<span class="string">"fget"</span>, T_OBJECT, <span class="keyword">offsetof</span>(propertyobject, prop_get), READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"fset"</span>, T_OBJECT, <span class="keyword">offsetof</span>(propertyobject, prop_set), READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"fdel"</span>, T_OBJECT, <span class="keyword">offsetof</span>(propertyobject, prop_del), READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"__doc__"</span>,  T_OBJECT, <span class="keyword">offsetof</span>(propertyobject, prop_doc), READONLY&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef property_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"getter"</span>, property_getter, METH_O, getter_doc&#125;,</span><br><span class="line">    &#123;<span class="string">"setter"</span>, property_setter, METH_O, setter_doc&#125;,</span><br><span class="line">    &#123;<span class="string">"deleter"</span>, property_deleter, METH_O, deleter_doc&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后，根据初始化方法可以看出需要输入get，set，del三个方法的函数指针（默认为None），然后会根据fget，fset，fdel所指向的函数作为改对象的<strong>get</strong>,<strong>set</strong>,<strong>del</strong>方法<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static <span class="type">int</span></span><br><span class="line">property_init(PyObject *self, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *<span class="keyword">get</span> = <span class="keyword">NULL</span>, *<span class="keyword">set</span> = <span class="keyword">NULL</span>, *del = <span class="keyword">NULL</span>, *doc = <span class="keyword">NULL</span>;</span><br><span class="line">    static <span class="type">char</span> *kwlist[] = &#123;"fget", "fset", "fdel", "doc", <span class="number">0</span>&#125;;</span><br><span class="line">    propertyobject *prop = (propertyobject *)self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO:property",</span><br><span class="line">                                     kwlist, &amp;<span class="keyword">get</span>, &amp;<span class="keyword">set</span>, &amp;del, &amp;doc))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">get</span> == Py_None)</span><br><span class="line">        <span class="keyword">get</span> = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">set</span> == Py_None)</span><br><span class="line">        <span class="keyword">set</span> = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (del == Py_None)</span><br><span class="line">        del = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(<span class="keyword">get</span>);</span><br><span class="line">    Py_XINCREF(<span class="keyword">set</span>);</span><br><span class="line">    Py_XINCREF(del);</span><br><span class="line">    Py_XINCREF(doc);</span><br><span class="line"></span><br><span class="line">    prop-&gt;prop_get = <span class="keyword">get</span>;</span><br><span class="line">    prop-&gt;prop_set = <span class="keyword">set</span>;</span><br><span class="line">    prop-&gt;prop_del = del;</span><br><span class="line">    prop-&gt;prop_doc = doc;</span><br><span class="line">    prop-&gt;getter_doc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if no docstring given and the getter has one, use that one */</span></span><br><span class="line">    <span class="keyword">if</span> ((doc == <span class="keyword">NULL</span> || doc == Py_None) &amp;&amp; <span class="keyword">get</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        PyObject *get_doc = PyObject_GetAttrString(<span class="keyword">get</span>, "__doc__");</span><br><span class="line">        <span class="keyword">if</span> (get_doc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Py_TYPE(self) == &amp;PyProperty_Type) &#123;</span><br><span class="line">                Py_XSETREF(prop-&gt;prop_doc, get_doc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If this is a property subclass, put __doc__</span></span><br><span class="line"><span class="comment">                in dict of the subclass instance instead,</span></span><br><span class="line"><span class="comment">                otherwise it gets shadowed by __doc__ in the</span></span><br><span class="line"><span class="comment">                class's dict. */</span></span><br><span class="line">                <span class="type">int</span> err = PyObject_SetAttrString(self, "__doc__", get_doc);</span><br><span class="line">                Py_DECREF(get_doc);</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prop-&gt;getter_doc = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_Exception)) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而@property当中的getter，setter，deleter方法则是建立了一个Copy了一个新的@property对象给对应的函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter方法</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">property_getter(PyObject *<span class="keyword">self</span>, PyObject *<span class="keyword">getter</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> property_copy(<span class="keyword">self</span>, <span class="keyword">getter</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter方法</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">property_setter(PyObject *<span class="keyword">self</span>, PyObject *<span class="keyword">setter</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> property_copy(<span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="keyword">setter</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deleter方法</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">property_deleter(PyObject *<span class="keyword">self</span>, PyObject *deleter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> property_copy(<span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, deleter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="property的Python实现"><a href="#property的Python实现" class="headerlink" title="@property的Python实现"></a>@property的Python实现</h2><p>根据源码的实现可以在python层实现一个@property系统<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="constructor">PyProperty(<span class="params">object</span>)</span>:</span><br><span class="line">def <span class="constructor">__init__(<span class="params">self</span>, <span class="params">field_get</span>=None, <span class="params">field_set</span>=None, <span class="params">field_del</span>=None)</span>:</span><br><span class="line">self.field_get_func = field_get</span><br><span class="line">self.field_set_func = field_set</span><br><span class="line">self.field_del_func = field_del</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="constructor">__set__(<span class="params">self</span>, <span class="params">instance</span>, <span class="params">value</span>)</span>:</span><br><span class="line"><span class="keyword">if</span> self.field_set_func is None:</span><br><span class="line">raise <span class="constructor">AttributeError('<span class="params">setter</span> <span class="params">not</span> <span class="params">exist</span>')</span></span><br><span class="line">return self.field<span class="constructor">_set_func(<span class="params">instance</span>, <span class="params">value</span>)</span></span><br><span class="line"></span><br><span class="line">def <span class="constructor">__get__(<span class="params">self</span>, <span class="params">instance</span>, <span class="params">type</span>=None)</span>:</span><br><span class="line"><span class="keyword">if</span> self.field_get_func is None:</span><br><span class="line">raise <span class="constructor">AttributeError('<span class="params">getter</span> <span class="params">not</span> <span class="params">exist</span>')</span></span><br><span class="line">return self.field<span class="constructor">_get_func(<span class="params">instance</span>)</span></span><br><span class="line"></span><br><span class="line">def <span class="constructor">__delete__(<span class="params">self</span>, <span class="params">instance</span>)</span>:</span><br><span class="line"><span class="keyword">if</span> self.field_del_func is None:</span><br><span class="line">raise <span class="constructor">AttributeError('<span class="params">deleteter</span> <span class="params">not</span> <span class="params">exist</span>')</span></span><br><span class="line">return self.field<span class="constructor">_del_func(<span class="params">instance</span>)</span></span><br><span class="line"></span><br><span class="line">def getter(self, get_method):</span><br><span class="line">return <span class="constructor">PyProperty(<span class="params">get_method</span> ,<span class="params">self</span>.<span class="params">field_set_func</span>, <span class="params">self</span>.<span class="params">field_del_func</span>)</span></span><br><span class="line"></span><br><span class="line">def setter(self, set_method):</span><br><span class="line">return <span class="constructor">PyProperty(<span class="params">self</span>.<span class="params">field_get_func</span> ,<span class="params">set_method</span>, <span class="params">self</span>.<span class="params">field_del_func</span>)</span></span><br><span class="line"></span><br><span class="line">def deleteter(self, del_method):</span><br><span class="line">return <span class="constructor">PyProperty(<span class="params">self</span>.<span class="params">field_get_func</span> ,<span class="params">self</span>.<span class="params">field_set_func</span>, <span class="params">del_method</span>)</span></span><br></pre></td></tr></table></figure></p><p>在@property里的getter，setter，deleter方法的实质上就是使用装饰的函数重写为了对应对象的<strong>get</strong>,<strong>set</strong>,<strong>delete</strong>方法从而达到了包装属性的神奇的效果，也完成了函数-&gt;成员变量的包装的变化。</p>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/b151bc1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>子集：回溯与枝剪</title>
      <link>https://ShinyGX.github.io/posts/95fd897/</link>
      <guid>https://ShinyGX.github.io/posts/95fd897/</guid>
      <pubDate>Tue, 18 Feb 2020 10:20:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;在求解子集的过程中，常常需要根据不同的情况进行不同的遍历与回溯。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在求解子集的过程中，常常需要根据不同的情况进行不同的遍历与回溯。</p><a id="more"></a><hr><p>求子集，实际上就是一种类似遍历一个集合的所有可能的过程。甚至，在一个简单的求子集问题当中，可以说就是一个遍历所有路径的过程。</p><p>因此，求子集的问题，一般可以通过画图的方式来解决。</p><h2 id="无需枝剪的子集问题"><a href="#无需枝剪的子集问题" class="headerlink" title="无需枝剪的子集问题"></a>无需枝剪的子集问题</h2><p>首先，是一个最基础的子集问题</p><blockquote><p><strong>给定一组不含重复元素的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</strong></p><p><strong>说明：解集不能包含重复的子集。</strong></p></blockquote><p>比如，集合<code>[1,2,3]</code>,所包含的子集就是<code>[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</code>,那么，求解的方法很明显就是遍历所有的组合了，这个时候我们可以画图来解决这个问题。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/95fd897/subset1.png"><p>从图中不难看出，从空集出发，不断地根据已选择的元素去递归的选择数组当中的剩余的元素，然后，将每一次的选择的路径保存下来，那么就是子集的内容了。</p><p>结合成代码就是这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;      </span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">       allsubsets(nums,res,<span class="built_in">set</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">allsubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">set</span>, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       result.push_back(<span class="built_in">set</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; nums.size();i++)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">set</span>.push_back(nums[i]);</span><br><span class="line">           allsubsets(nums,result,<span class="built_in">set</span>,i + <span class="number">1</span>);</span><br><span class="line">           <span class="built_in">set</span>.pop_back();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当然，在递归地遍历地时候，要注意，每一次函数返回之后都要将set的值回溯，因为，set里面所保存的是递归遍历时候的路径，当函数弹出之后，路径自然也要回溯回来了。</p><p>然后，将路径保存在结果中，最后也自然能够得到答案了。</p><p><strong>题目来源(LeetCode)</strong><br>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/95fd897/#disqus_thread</comments>
    </item>
    
    <item>
      <title>引用计数式智能指针</title>
      <link>https://ShinyGX.github.io/posts/dbb7ef5e/</link>
      <guid>https://ShinyGX.github.io/posts/dbb7ef5e/</guid>
      <pubDate>Thu, 19 Dec 2019 15:59:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;既然手动内存管理这么麻烦，那么为什么来一个自动的内存管理呢&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>既然手动内存管理这么麻烦，那么为什么来一个自动的内存管理呢</p><a id="more"></a><hr><p>在<code>c++</code>当中，对于一个<code>new</code>,就要对应一个<code>delete</code>，进行相对应的内存释放。只要成对的出现分配与释放，那自然就不会引起任何内存泄漏的问题。但是，说很简单，但是当做起来的时候就未必了。比如对于一个函数返回的指针，我们需不需要对其进行内存的释放呢？而对于一个传入的指针，我们又需不需要对其进行内存的分配呢？还有，下面这种情况<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *p1 = p;</span><br><span class="line">......</span><br><span class="line">p5 = p4 = p3 = p2 = p1 = p</span><br></pre></td></tr></table></figure></p><p>当我们有很多变量都需要p的时候，我们应不应该释放<code>pn</code>？这个时候，我们就需要利用一些东西去让我们自动的管理指针了。</p><p>我们面对的问题无非就是怎么样让指针在应该释放的时候释放，不应该释放的时候不会释放，以及一定要指针得到释放。首先，其实我们可以对于每一个内存块都建立一个计数器，一旦有指针指向这个内存块，我们就使得计数器增加，当有一个指针被释放的时候，我们就减少我们的计数器，当计数器为0的时候才真正的去释放这一块的内存。这个方法，就叫做引用计数法。</p><p>还有一个问题就是，怎么样才能让指针不再使用的时候就能够得到释放呢？</p><p>其实这个问题，我们可以参考一下栈上的临时变量，当函数调用的时候，栈上的空间被申请，而里面的临时变量都会同时被申请了出来，但是，当执行完函数的时候，临时变量也同样会被析构。因此，我们可以利用这个特点，将指针封装到一个对象上去，那就是智能指针了。</p><h2 id="RCObject"><a href="#RCObject" class="headerlink" title="RCObject"></a>RCObject</h2><p>在实现指针之前，我们有一个东西要处理，那就是计数器。按照我们之前的想法，所有内存都使用一个计数器去管理，因此，我们首先来实现这个计数器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    RCObject();</span><br><span class="line">    RCObject(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~RCObject() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当有一个指针进来引用同一块内存的时候，我们就增加计数器，当有指针被销毁的时候减少引用，当然，这些都是智能指针应该去干的事情，这里只是一个计数器。当然，计数器同时也要拥有一个判断当前内存块是不是被共享的方式，至于具体原因之后再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RCObject::RCObject()</span><br><span class="line">       :refCount(<span class="number">0</span>),shareable(<span class="literal">true</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   RCObject::RCObject(<span class="keyword">const</span> RCObject&amp; rhs)</span><br><span class="line">       :refCount(<span class="number">0</span>),shareable(<span class="literal">true</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//虽然是纯虚函数，但是必须要提供一个实现，因为这是一个析构函数，派生类调用自身的析构的时候一定会调用它的</span></span><br><span class="line">   RCObject::~RCObject()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> RCObject::addReference()&#123;++refCount;&#125;</span><br><span class="line">   <span class="keyword">void</span> RCObject::removeReference()&#123;<span class="keyword">if</span>(--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">   <span class="keyword">void</span> RCObject::markUnshareable()&#123;shareable = <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">bool</span> RCObject::isShareable() <span class="keyword">const</span> &#123; <span class="keyword">return</span> shareable;&#125;</span><br><span class="line">   <span class="keyword">bool</span> RCObject::isShared() <span class="keyword">const</span> &#123;<span class="keyword">return</span> refCount &gt; <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="RCPtr"><a href="#RCPtr" class="headerlink" title="RCPtr"></a>RCPtr</h2><p>首先，先思考一下这个东西要有什么样的效果。首先能够自动对内存进行管理那当然是必须的。然后，还需要能够兼容指针的操作，换句话说就是像指针一样的使用方式，那么<code>*,-&gt;</code>这些操作符肯定要重载的，还有就是那些指针的判空操作比如<code>if(ptr)</code>，当然，我们可以假如一个<code>isEmpty()</code>的方法，但是，这样不是很够自然，因此我们需要一些能够隐式转换类型的方式，那么说，<code>operator bool()</code>是要去建立的。还有就是感叹号的<code>!</code>，这样也可以去兼容<code>if(!ptr)</code>这种判断方式。</p><p>另外还有一个问题就是，当我们对指针进行操作的时候，由于我们都是指向同一个内存的，但是，我的想法肯定不是想要<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptrb = ptra;</span><br><span class="line">ptrb-&gt;doSomething();</span><br></pre></td></tr></table></figure></p><p>之后，就改变了<code>ptra</code>的内容，因此，我们需要在对<code>ptrb</code>进行操作的时候，对其进行写时复制。将指针的复制操作延缓到真的要实际操作的时候才进行复制，这样对于需要引用大量同样的对象却使用比较少的情况有比较少的优化效果。当然，假如你想同时操作两个对象，那么这个就不太适合这种情况了。而之前所说的判断空间是否被分享的作用也就于此。</p><p>既然需要实现的内容都清楚了，我们就可以去实现内容了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>)</span><br><span class="line">        :pointee(realPtr)</span><br><span class="line">    &#123; init(); &#125;</span><br><span class="line">    RCPtr(RCPtr&amp; rhs)</span><br><span class="line">        :pointee(rhs.pointee)</span><br><span class="line">    &#123; init(); &#125;</span><br><span class="line">    ~RCPtr()&#123; holder-&gt;removeReference(); &#125;</span><br><span class="line"></span><br><span class="line">    RCPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(RCPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用const与否来判断接下来的对象是否需要用到写时复制</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*();</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">RCPtr&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> RCPtr&lt;T&gt;::<span class="keyword">operator</span>!() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pointee == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;tyepname T&gt;</span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;tyepname T&gt; </span><br><span class="line">RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>=(RCPtr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pointee != rhs.pointee)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pointee)</span><br><span class="line">        &#123;</span><br><span class="line">            pointee-&gt;removeReference();</span><br><span class="line">        &#125;</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        pointee-&gt;addReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::makeCopy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pointee-&gt;isShared())</span><br><span class="line">    &#123;</span><br><span class="line">        T *oldValue = pointee;</span><br><span class="line">        pointee-&gt;removeReference();</span><br><span class="line">        pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pointee-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pointee == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pointee-&gt;isShareable() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pointee = <span class="keyword">new</span> T(*pointee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pointee-&gt;addReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们仍然面临着两个问题，首先，就是派生类的问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A:</span><br><span class="line"></span><br><span class="line">megre(<span class="keyword">const</span> RCPtr&lt;A&gt;&amp; a1,<span class="keyword">const</span> RCPtr&lt;A&gt;&amp; a2);</span><br><span class="line"></span><br><span class="line">RCPtr&lt;B&gt; b;</span><br><span class="line">RCPtr&lt;C&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line">megre(b,c);</span><br></pre></td></tr></table></figure></p><p>虽然在指针上，这两个拥有派生类的家伙能够用隐式转换的方式进行正确的传递。但是，这个在<code>RCPtr&lt;T&gt;</code>之中就完全不行了，因为，虽然泛型的参数是有继承关系的，但是两个类实际上毫无关联。因此，为了解决这个问题，我们就需要使用类型转换的重载了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">operator</span> <span class="title">RCPtr</span>&lt;newType&gt;()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> RCPtr&lt;newType&gt;(pointee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，这里使用了泛型重载了类型变换，但是，构造函数的指针赋值操作会为我们检查这个操作是否合法，也就是说只有属于同一条继承链上的人才会得到正确的转换</p><h2 id="RCHolder"><a href="#RCHolder" class="headerlink" title="RCHolder"></a>RCHolder</h2><p>接下来就是一个很重要的问题，那就是，我用这个智能指针还必须要参数对象T要继承<code>RCObject</code>才能操作是不是很不方便？？？</p><p>没错，确实十分不方便，因此，我们现在就来解决这个问题。有句话说过，计算机当中的所有问题都能够通过增加一个层来解决，因此，同样的，我们可以为这个指针增加一个中间层，专门用来处理计数器的</p><p>我们现在的情况是这样的。智能指针记录了指针，指针身上有一个计数器，智能指针控制指针身上的计数器，当计数器归零的时候，就会销毁指针。那么，其实可以看出来，计数器对于指针来说并不是一个必须的东西，我们可以在中间加一个holder，变成这样的方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">             RCObject</span><br><span class="line">               |</span><br><span class="line">               | </span><br><span class="line">RCPtr&lt;T&gt; --&gt; Holder --&gt; pointee</span><br></pre></td></tr></table></figure></p><p>计数器管理Holder，对智能指针的操作都会反映到holder身上，而holder持有pointee，当计数器归零的时候，holder会销毁，而holder所持有的pointee也会顺势销毁，这样，指针和计数器之间的耦合关系就被解除了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>)</span><br><span class="line">        :holder(<span class="keyword">new</span> RCHolder())</span><br><span class="line">    &#123; holder-&gt;pointee = realPtr; init(); &#125;</span><br><span class="line">    RCPtr(RCPtr&amp; rhs)</span><br><span class="line">        :holder(rhs.holder)</span><br><span class="line">    &#123; init(); &#125;</span><br><span class="line">    ~RCPtr()&#123; holder-&gt;removeReference(); &#125;</span><br><span class="line"></span><br><span class="line">    RCPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(RCPtr&lt;T&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*();</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">operator</span> <span class="title">RCPtr</span>&lt;newType&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RCHolder</span> :</span> <span class="keyword">public</span> RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        T *pointee;</span><br><span class="line">        ~RCHolder()&#123; <span class="keyword">delete</span> pointee; pointee = <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RCHolder *holder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;newType&gt;</span><br><span class="line">RCPtr&lt;T&gt;::<span class="keyword">operator</span> RCPtr&lt;newType&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> RCPtr&lt;newType&gt;(holder-&gt;pointee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">RCPtr&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> holder-&gt;pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> RCPtr&lt;T&gt;::<span class="keyword">operator</span>!() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> holder-&gt;pointee == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(holder-&gt;pointee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;tyepname T&gt;</span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> holder-&gt;pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    <span class="keyword">return</span> holder-&gt;pointee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    <span class="keyword">return</span> *(holder-&gt;pointee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;tyepname T&gt; </span><br><span class="line">RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>=(RCPtr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(holder != rhs.holder)</span><br><span class="line">    &#123;</span><br><span class="line">        holder-&gt;removeReference();</span><br><span class="line">        holder = rhs.holder;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::makeCopy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(holder-&gt;isShared())</span><br><span class="line">    &#123;</span><br><span class="line">        T *oldValue = holder-&gt;pointee;</span><br><span class="line">        holder-&gt;removeReference();</span><br><span class="line">        holder = <span class="keyword">new</span> RCHolder();</span><br><span class="line">        holder-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">        holder-&gt;addReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!holder-&gt;isShareable())</span><br><span class="line">    &#123;</span><br><span class="line">        T *oldValue = holder-&gt;pointee;</span><br><span class="line">        holder = <span class="keyword">new</span> RCHolder;</span><br><span class="line">        holder-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder-&gt;addReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终就会是这个样子了</p><h2 id="与share-ptr"><a href="#与share-ptr" class="headerlink" title="与share_ptr"></a>与share_ptr</h2><p>stl当中的<code>share_ptr</code>与这个的设计都是使用了引用计数的方式，但是不同的一点在与，<code>share_ptr</code>对于一个被复制的指针保留了原有的指针的效果，也就说不会写时复制，当另一个指针修改了内容之后，这个内存块的位置也会被修改。从设计上来说，感觉<code>share_ptr</code>与原生的指针的操作会更加的相似一些，而我这里的操作会对于每一个指针的持有者都会有独一无二的内存空间，也就没有了共享指针这种操作了。</p><blockquote><p><strong>参考书籍《more effective c++》，这里也是里面的RCPtr的设计</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/dbb7ef5e/#disqus_thread</comments>
    </item>
    
    <item>
      <title>引用计数式的String</title>
      <link>https://ShinyGX.github.io/posts/93e26237/</link>
      <guid>https://ShinyGX.github.io/posts/93e26237/</guid>
      <pubDate>Wed, 18 Dec 2019 21:16:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;与std::string不一样的string&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>与std::string不一样的string</p><a id="more"></a><hr><p>在std::string当中，虽然提供了很多string的操作，但是，在内存上它的本质也只是一个<code>vector&lt;char&gt;</code>而已，对于以下的状态<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = str1;</span><br></pre></td></tr></table></figure></p><p>在实际上是两段完全不同的内存。但是，假如我们变成这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5 = str4 = str3 = str2 = str1;</span><br></pre></td></tr></table></figure></p><p>那岂不是对于一个相同的字符串却申请了五段的内存。这其实是一种浪费。我们完全可以只用一段内存，而其他的strn只需要持有那段内存的指针就可以了。这样，我们就可以减少内存的消耗了。同时，为了防止有人一不小心就将这段内存给销毁，因此，我们可以拿一个计数器去记录一共有多少人在同时持有这段内存。一旦有人<code>delete strn</code>了，就将计数器减一，直到计数器为零的时候才将这段内存给销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">removeReferenceCount();</span><br><span class="line"><span class="keyword">if</span>(referenceCount == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是着种感觉吧。这种技术就称之为<strong>引用计数</strong></p><p>不过，现在还有一个问题，那就是既然是多人同时持有一个内存块，那么就会导致一个问题，那就是比如<code>strn[0] = &#39;y&#39;</code>那么，所有人都会受到波及。这明显不是我们想要看到的，因此，我们为了防止这种现象，当需要修改这个<code>strn</code>的时候，我们先将内存块复制一份，然后，<code>strn</code>独自持有这一份的内存。那么，它无论怎么去修改它自己的字符串都不是问题了。</p><p>这也是和String的初衷是一样的，那就是不会改变原有的使用方式，每一个str在用户看来都是独立的，即使内存是映射到同一个区域<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const是不会被改变的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设所有使用非const版本的operator[]都是会修改字符串的</span></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">makeCopy();</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大概的思路就是这样的。这种技术就叫做<strong>写时复制</strong>，在操作系统的进程与子进程之间的内存映射也是用到了这种技术哦。</p><p>既然大致的思路都已经思考出来了，我们就考虑实现吧。</p><p>既然都说到写时复制,那么，我们完全可以使用之前所说的<a href="https://dearsummer.github.io/posts/dbb7ef5e/#%E6%9B%B4%E5%A4%9A" target="_blank" rel="noopener">RCPtr</a>去实现这个对于字符串的内存共享的功能。</p><h2 id="StringValue"><a href="#StringValue" class="headerlink" title="StringValue"></a>StringValue</h2><p>立即行动，将String实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String (<span class="keyword">const</span> <span class="keyword">char</span> *value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line"></span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中里面的StringValue就是用来缓存字符串的，而在外部使用了<code>RCPtr&lt;StringValue&gt;</code>确保了对字符串的内容的正确的缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::StringValue::init(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</span><br><span class="line">  &#123;</span><br><span class="line">      data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(data,initValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</span><br><span class="line">  &#123;</span><br><span class="line">      init(initValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String::StringValue::StringValue(<span class="keyword">const</span> StringValue&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">      init(rhs.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String::StringValue::~StringValue()</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当需要新的字符串类型的时候会生成新的<code>StringValue</code>，假如对于字符串的修改没有任何问题的话，那么，就会增加引用计数。不过，这里有一个问题，我们和<code>RCPtr</code>里面的设计是一样的，假设<code>const char&amp; operator[](int i) const</code>为不改变字符串的方式而<code>char&amp; operator[](int i)</code>为改变字符串的方式。但实际上，我们对于调用哪一个函数并不取决于是否会发生改变，而仅仅是因为类型匹配而已，假如发生了这种事情。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">'y'</span>;</span><br></pre></td></tr></table></figure></p><p>我们可以认为，第三行的操作会影响到字符串而第二行的操作却没有。但是，我们调用的很可能是同一个<code>operator[]</code>，因为，这个并不取决于是否发生了改变。因此，我们需要一种方式去更加的准确的预测是否会引起字符串的改变的操作。</p><h2 id="CharProxy"><a href="#CharProxy" class="headerlink" title="CharProxy"></a>CharProxy</h2><p>我们需要一个代理类。代理类的作用其实只是为我们争取到时间，争取到我们确切的操作字符的时候我们才确认我们的操作到底是应该怎么去做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CharProxy</span></span></span><br><span class="line"><span class="class">       &#123;</span></span><br><span class="line">           CharProxy(String&amp; s,<span class="keyword">int</span> index);</span><br><span class="line">           </span><br><span class="line">           CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; ths);</span><br><span class="line">           CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">char</span>* <span class="keyword">operator</span>&amp;();</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span>:</span><br><span class="line">           String&amp; str;</span><br><span class="line">           <span class="keyword">int</span> charIndex;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><p>首先，我们<code>String</code>返回的<code>operator[]</code>变成了<code>CharProxy</code>。那么，外界持有这个代理类的时候，当使用了赋值操作的时候，那么，就会触发<code>operator=</code>的操作，那么自然而然就会触发写时复制。而假如仅仅是使用这个字符，那么，自然就会隐式转换到char的类型,因为定义了<code>operator char()</code>方法。而这个时候就不会触发写时复制了。也就节省了以此内存拷贝的操作。</p><p>同样，因为我们使用了代理类，那么我们有一些操作就会和<code>char</code>的操作不一样。为了消除这种不一致的行为，我们就将一些操作给重载了，这里重载了取地址的运算。因为，其他运算可以通过对char的隐式转换而达成。值得一提的是，因为取了地址就有了潜在的修改的可能，因此，也需要进行写时复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String (<span class="keyword">const</span> <span class="keyword">char</span> *value);</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CharProxy</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        CharProxy(String&amp; s,<span class="keyword">int</span> index);</span><br><span class="line">        </span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; ths);</span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* <span class="keyword">operator</span>&amp;();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        String&amp; str;</span><br><span class="line">        <span class="keyword">int</span> charIndex;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> String::CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    String::CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os,<span class="keyword">const</span> String&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CharProxy</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line"></span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *initValue = <span class="string">""</span>)</span><br><span class="line">    :value(<span class="keyword">new</span> StringValue(initValue))&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> String::CharProxy String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> String::CharProxy(<span class="keyword">const_cast</span>&lt;String&amp;&gt;(*<span class="keyword">this</span>),index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::CharProxy String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> String::CharProxy(*<span class="keyword">this</span>,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::CharProxy::CharProxy(String&amp; s,<span class="keyword">int</span> index)</span><br><span class="line">    :str(s),charIndex(index)&#123;&#125;</span><br><span class="line"></span><br><span class="line">String::CharProxy::<span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.value-&gt;data[charIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os,<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; str.value-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *String::CharProxy::<span class="keyword">operator</span>&amp;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(str.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * String::CharProxy::<span class="keyword">operator</span>&amp;()</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    str.value-&gt;markUnshareable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;(str.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::CharProxy&amp; String::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">const</span> String::CharProxy&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    str.value-&gt;data[charIndex] = rhs.str.value-&gt;data[rhs.charIndex];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::CharProxy&amp; String::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    makeCopy();</span><br><span class="line">    str.value-&gt;data[charIndex] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::CharProxy::makeCopy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.value-&gt;isShared())</span><br><span class="line">    &#123;</span><br><span class="line">        RCPtr&lt;StringValue&gt; rcptr(<span class="keyword">new</span> StringValue(str.value-&gt;data));</span><br><span class="line">        str.value = rcptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::StringValue::init(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data,initValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</span><br><span class="line">&#123;</span><br><span class="line">    init(initValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::StringValue::StringValue(<span class="keyword">const</span> StringValue&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    init(rhs.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::StringValue::~StringValue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理类可以延缓我们的操作，直到真正在使用它的时候才进行操作。这符合了<code>lazy evaluation</code>的优化守则，因此，对于引用多而修改少的时刻会比较有优势。</p><blockquote><p>参考书籍《more effective c++》 这是里面的String的实现方式</p></blockquote>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/93e26237/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stl:copy/copy_backward</title>
      <link>https://ShinyGX.github.io/posts/fffcaacd/</link>
      <guid>https://ShinyGX.github.io/posts/fffcaacd/</guid>
      <pubDate>Thu, 12 Dec 2019 16:41:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;copy(first,last,result)&lt;br&gt;copy_backward(first,last,result);&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>copy(first,last,result)<br>copy_backward(first,last,result);</p><a id="more"></a><hr><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>在stl当中，copy是从前往后拷贝的，也就是说<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;first != last;++first)</span><br><span class="line">*result = *first;</span><br></pre></td></tr></table></figure></p><p>大致是这种形式的，因此，当result的头部区域处于<code>[first,last)</code>之间的时候，就会有可能出现拷贝出错的情况。<br>比如<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">  |   | |</span><br><span class="line"> first| last</span><br><span class="line">     result</span><br></pre></td></tr></table></figure></p><p>这种情况，在first还没遍历到3之前，3已经作为result被修改了，因此，会出现拷贝出错的情况。但是，之所以说是可能出现出错的情况，是因为，copy进行了大量的泛化，特化与强化的工作，因此，也有可能不会有问题。</p><p>在copy当中，为了保证效率的最高，它将拷贝的操作分为两种可能，一种是对<code>char*/wchar_t*</code>进行的操作，另一种是非<code>char*/wchar_t*</code>进行的操作。当类型推导推导出这个特化的类型的时候，它就会调用<code>memmove()</code>来进行拷贝，这是一个很快的底层拷贝操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于wchar_t*也一样（利用函数的重载的功能）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* first,<span class="keyword">const</span> <span class="keyword">char</span>* last,<span class="keyword">const</span> <span class="keyword">char</span>* result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">memmove(result,first,last - first);</span><br><span class="line"><span class="keyword">return</span> result +(last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于非字符指针之外的操作，就是完全的泛化的操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> <span class="title">copy</span>(</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">OutputIterator</span> <span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> __copy_dispatch&lt;InputIterator,OutputIterator&gt;()</span><br><span class="line">(first,last,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，虽然是泛化的版本，但是，在这里对于不同的Iteraotr也是进行不同的特化的操作的，当迭代器为指针类型，也就是说要对指针进行操作的时候，那就要看这个指针有没有<em>trivial operator=</em>当存在着支持这种原生的指针操作的时候，自然也要使用效率极高的<code>memmove()</code>了。不然，就是用复制的强化版操作，因此，当你自定义了指针赋值操作后，我们是不知道你要怎么对对象进行赋值的，因此，直接拷贝内存这种粗暴的方式自然是不可行的。</p><p>假如，迭代器不是指针类型，那就同样要看这个迭代器的类型是怎么样的了，假如这个迭代器是随机访问的迭代器，那就说明能够很简单的求得拷贝区域的长度，因此，也可以使用强化版本，不然，那就只能使用最简单的也是最慢的最泛化的版本了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用了仿函数进行内容的特化，根据萃取出的不同的iterator来进行不同的操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">copy_dispath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">InputIterator first,InputIteratorlast,OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __copy(first,last,result,iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看的是泛化的版本，也就是根据不同的iterator来进行强化的copy方式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">InputIterator,<span class="symbol">class</span></span> <span class="symbol">OutputIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">OutputIterator</span> <span class="symbol">__copy</span>(</span><br><span class="line"><span class="symbol">InputIterator</span> <span class="symbol">first,<span class="symbol">InputIterator</span></span> <span class="symbol">last,</span></span><br><span class="line"><span class="symbol">OutputIterator</span> <span class="symbol">result,<span class="symbol">input_iterator_tag</span></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;first != last;++result,++first)</span><br><span class="line">*result = *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">OutputIterator</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">OutputIterator</span> <span class="symbol">__copy</span>(</span><br><span class="line"><span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,</span></span><br><span class="line"><span class="symbol">OutputIterator</span> <span class="symbol">result,<span class="symbol">random_access_iterator_tag</span></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __copy_d(first,last,result,distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">RandomAccessIterator,<span class="symbol">class</span></span> <span class="symbol">OutputIterator,<span class="symbol">class</span></span> <span class="symbol">Distance</span>&gt;</span><br><span class="line"><span class="symbol">inline</span> <span class="symbol">OutputIterator</span> <span class="symbol">__copy_d</span>(</span><br><span class="line"><span class="symbol">RandomAccessIterator</span> <span class="symbol">first,<span class="symbol">RandomAccessIterator</span></span> <span class="symbol">last,</span></span><br><span class="line"><span class="symbol">OutputIterator</span> <span class="symbol">result,<span class="symbol">Distance</span></span> *)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(Distance n = last - first;n &gt; <span class="number">0</span>;--n,++result,++first)</span><br><span class="line">*result = *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而RandomAccessIterator比较快的原因，大致就是因为不用一直对比迭代器，因此就避免了大量访问迭代器的时间。</p><p>之后，就是对于指针类型的强化了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">copy_dispath</span>&lt;T*,T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function">T* <span class="title">operator</span><span class="params">()</span><span class="params">(T* first,T*,T* result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">__copy_t</span>(first,last,result,t());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数为const的版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">copy_dispath</span>&lt;const T*,T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span>...&#125;</span><br></pre></td></tr></table></figure><p>由于要分为是否有<em>trivial operator=</em>，因此，在调用的时候，就先萃取出了t，来判断有没有原生的指针，然后，根据不同的类型来进行不同的拷贝操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* __<span class="title">copy_t</span>(<span class="title">const</span> <span class="title">T</span>* <span class="title">first</span>,<span class="title">const</span> <span class="title">T</span>* <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>* <span class="title">result</span>,__<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">memmove(result,first,<span class="keyword">sizeof</span>(T) * (last - first));</span><br><span class="line"><span class="keyword">return</span> first +(last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* __<span class="title">copy_t</span>(<span class="title">const</span> <span class="title">T</span>* <span class="title">first</span>,<span class="title">const</span> <span class="title">T</span>* <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>* <span class="title">result</span>,__<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> __copy_d(first,last,result,(<span class="keyword">ptrdiff_t</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，copy的所有操作都进行了尽可能的优化了</p><h2 id="move-backward"><a href="#move-backward" class="headerlink" title="move_backward"></a>move_backward</h2><p>move_backward的优化方式与copy是完全一样的。而它的拷贝方式则是与copy相反，它是从尾到头开始拷贝的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--last;</span><br><span class="line"><span class="keyword">for</span>(;first != last;--last,--result)</span><br><span class="line">*result = *last;</span><br></pre></td></tr></table></figure></p><p>因此，假如拷贝区间的尾部处于<code>[first,last)</code>之间的话，拷贝就有可能出错</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">| |   | |</span><br><span class="line">|first| last</span><br><span class="line">result|</span><br></pre></td></tr></table></figure><p>假如result的区间是<code>[0,3)</code>，当从last开始拷贝的时候，就已经破坏了<code>[first,last)</code>还未拷贝的地方，因此，有可能会出错</p><p>当然，当时用<code>memmove()</code>的时候是不会出错的。</p><ul><li>参考资料《stl源码剖析》</li></ul>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/fffcaacd/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stl:sort</title>
      <link>https://ShinyGX.github.io/posts/bb1dff1a/</link>
      <guid>https://ShinyGX.github.io/posts/bb1dff1a/</guid>
      <pubDate>Wed, 11 Dec 2019 17:16:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;void sort(first,last)&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>void sort(first,last)</p><a id="more"></a><hr><p>在STL当中的sort的算法，并不是一个简单的单一的算法，是一个复合的算法，里面涵盖了堆排序，快速排序和插入排序</p><ul><li>当数据量比较少的时候，快速排序体现不到其优势，而且会因为使用递归带来比较大的额外开销，因此使用的是插入排序</li><li>当数据量比较大的时候，就会使用快速排序。但是，快速排序有一个缺点，那就是当数据量大部分有序的时候，就会导致时间复杂度倾向于O(n^2)，因此，当时间复杂度有向O(n^2)倾斜的时候，就会改为使用堆排序，从而将时间复杂度最坏情况控制在O(nlogn)</li><li>再者，由于插入排序在大量元素有序的情况下，性能将会十分的好，因此，当快速排序到达”就差一点点就全部有序”的状态的时候，改为使用插入排序对元素进行最终的排序</li></ul><p>因此，在stl当中的排序是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIteratorlast</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">if</span>(first != last)</span><br><span class="line">&#123;</span><br><span class="line">__introsort_loop(first,last,value_type(first),__lg(last-first) * <span class="number">2</span>);</span><br><span class="line">__final_insertion_sort(first,last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>__introsort_loop</code>就是之前所说的堆，快排，插入排序的复合排序了</p><p>首先，我们要知道，想要知道元素要多大才是快排，又要多大才是插入排序，我们就需要一个阈值,这个阈值是一个全局的变量<code>const int __stl_threshold = 16;</code>。首先，对元素进行数量上的检查，根据数量上的差别来判断是否使用快速排序。</p><p>第二点就是要检查元素是否是大部分有序的了。这个，我们可以从快排的分割上入手。因此，在理想情况下，快速排序每一次的分割都能很好的对半分层，因此，理论上在最好的情况下就需要分logn层，一旦元素大部分有序，就需要多很多次的分割，因此，我们可以为这个分割设定一个阈值，一旦超过这个阈值，就说明元素的排序并不是很理想，要使用堆排序了，这个阈值就是函数<code>__lg(size)</code>了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Size</span> __<span class="title">lg</span>(<span class="title">Size</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Size k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>;n &gt; <span class="number">1</span>;n &gt;&gt; <span class="number">1</span>) ++k;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设数组元素是40个，那么期望的分层就是5，那么我们对其的最大分割限制就是5*2;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>,<span class="title">class</span> <span class="title">T</span>，<span class="title">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIrerator</span> <span class="title">last</span>,<span class="title">T</span>*,<span class="title">Size</span> <span class="title">depth_limit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//在这里，利用了阈值很巧妙的将排序到"差一点就完成"的状态构建了出来</span></span><br><span class="line"><span class="keyword">while</span>(last - first &gt; __stl_threshold)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(depth_limit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这个就是堆排序</span></span><br><span class="line">partial_sort（first,last,last);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--depth_limit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排的partition，在这里使用的是三点分割</span></span><br><span class="line"><span class="comment">//意思是，取piovt的时候，取第一个元素，最后一个元素，和中间的元素当中的中值当作piovit</span></span><br><span class="line">RandomAccessIterator cut = __unguarded_partition(</span><br><span class="line">first,last,</span><br><span class="line">T(__median(*first,*(first + (last - first) / <span class="number">2</span>),*(last - <span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">//先对右半边进行递归</span></span><br><span class="line">__introsort_loop(cut,last,value_type(first),depth_limit);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一次就是对左半边了</span></span><br><span class="line">last = cut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;RandomAccessIterator&gt;</span><br><span class="line"><span class="keyword">void</span> __final_insertion_sort(RandomAccessIterator first,RandomAccessIterator last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//假如元素数量小于阈值，直接插入排序，否则用插入排序为快排收尾</span></span><br><span class="line"><span class="keyword">if</span>(last - first&gt; __stl_threshold)</span><br><span class="line">&#123;</span><br><span class="line">__insertion_sort(first,first + __stl_threshold);</span><br><span class="line">__unguarded_insertion_sort(first + __stl_threshold,last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__insert_sort(first,last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考资料《stl源码剖析》</li></ul>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/bb1dff1a/#disqus_thread</comments>
    </item>
    
    <item>
      <title>stl:partial_sort</title>
      <link>https://ShinyGX.github.io/posts/b0a82fc8/</link>
      <guid>https://ShinyGX.github.io/posts/b0a82fc8/</guid>
      <pubDate>Wed, 11 Dec 2019 16:21:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;void partial_sort(first,middle,last);&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>void partial_sort(first,middle,last);</p><a id="more"></a><hr><p>在stl当中，<code>partial_sort(first,middle,last)</code>，是一个局部排序的算法，是从<code>[first,end)</code>的区间中对元素进行排序，最终使得<code>[first,middle)</code>中的元素为<code>[first,last)</code>当中的前k个。</p><p>这个问题其实就是从一个数组当中从小到大排序k个元素，与直接排列整个数组的<code>sort</code>不同，当k相较于数组长度n比较小的时候，这个排序将会比直接排序整个数组快很多。</p><p>实现这个排序的思路就在于维护一个最大堆</p><ul><li>首先，建立一个从<code>[first,middle)</code>之间的元素的最大堆</li><li>然后，在<code>[middle,last)</code>区间中进行向后的扫描，当遇见一个比堆顶元素小的元素的时候，弹出堆顶元素并将这个新的元素加入到堆当中</li><li>最后，扫描完成后，堆中的元素最大的也是第k大的元素了，因此，对堆进行堆排序，从而实现<code>[first,middle)</code>之间的有序</li></ul><p>首先，建立一个堆，以及对堆的插入的操作时间复杂度都是O(logk)的，扫描整个数组，因此是O(nlogk)，然后，要对堆内进行堆排序，因此整个算法的时间复杂度应该是O((n+k)logk),空间复杂度要维护整个堆k个元素，因此是O(k)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__partial_sort(first,middle,last,value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">partial_sort</span>( <span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*);</span></span><br><span class="line">&#123;</span><br><span class="line">make_heap(first,middle);</span><br><span class="line"><span class="keyword">for</span>(*i &lt; *first)</span><br><span class="line">__pop_heap(first,middle,i,T(*i),distance_type(first));</span><br><span class="line">sort_heap(first,middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用资料《stl源码剖析》</li></ul>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/b0a82fc8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>莉兹与青鸟</title>
      <link>https://ShinyGX.github.io/posts/807cefa7/</link>
      <guid>https://ShinyGX.github.io/posts/807cefa7/</guid>
      <pubDate>Fri, 06 Dec 2019 16:12:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;谁是谁的莉兹，谁又是谁的青鸟呢？&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>谁是谁的莉兹，谁又是谁的青鸟呢？<br><a id="more"></a></p><hr><p>《莉兹与青鸟》一改《京吹》两部的风格，用精致的画面，细腻的情感为我们展开了两位少女之间的感人的故事。</p><p>“你是不是没有加入任何社团呢？”，“是”，“那要不要加入吹奏部呢？”。在初中，希美如同青鸟一般闯入了内向的少女霙的生活当中，她们一起演奏一起参加比赛，最终，落选，没有成功打入全国比赛，但是，她们约定要在高中一起继续努力，她们的目标：全国大赛。</p><p>神经大条的希美不知道，霙的双簧管只为她一人所奏。</p><p>时光流逝，她们如愿在北宇治高中加入了吹奏部，但是，在这里，不愿努力的三年级与积极前进的一年级发生了剧烈的冲突，最终导致一年级生大量退部，其中就包括了希美，但是，希美却没有告诉霙她的退出，一如利兹与青鸟的故事当中，在利兹睡下之时，悄然离去的青鸟。</p><p>在这之后，发生了许多故事，希美如同青鸟一般在利兹醒来之时回到了利兹的身边，她回到了吹奏部当中，但是，两人的关系，又如同片中开头所描绘一样，如同两条线，不断的靠近，而一旦接近又会立即离开。</p><p>童话故事《利兹与青鸟》一直穿插在故事当中，一如霙的内心，她一直认为她是利兹，是她束缚着最求自由翱翔的希美。但是，就如同在演奏利兹与青鸟的时候，她始终无法理解放飞青鸟的利兹是什么感受，“如果我是利兹，我会将青鸟锁在笼子里，让我们永远的在一起”，她不知道为什么要放手所爱之人。直到与老师的交谈当中，换位思考之后才发现，其实她才是青鸟，她才是希美一直所希望展翅高飞的那个人，“在利兹放飞青鸟的时候，青鸟到底是怎么样的感受呢？”，“即使不舍，也要展翅高飞，因为这是利兹所希望的，因为青鸟的一切都只是为了让利兹幸福”</p><p>在最后的演奏当中，希美也终于明白，其实她才是利兹，一直束缚着霙的利兹。因为，自己的演奏跟不上更有才华的霙，因此，霙才会一直以来压抑着自己的声音，以此来迎合希美的步伐。“让我觉得最难受的事情是，让我知道了打开鸟笼的方法”，利兹的独白一如希美的内心。</p><p>最终，两位少女心与心的碰撞终于将两条不相交的线条重合在了一起，一如片中的将”disjoint”中的”dis”划掉的”joint”一般。但与开头两人无言却默契的走在一起相比，希美与霙多了对话，也更拉近了彼此的距离。</p><p>与《京吹》中久美子的爆发般的炽热感情对比，《利兹与青鸟》全片细腻而内敛，一如内向的霙一般。整个剧场版通过大量的细节动作的描绘，很形象的表达了霙内心的那种，“我喜欢你，但是为了你我将会学会自由飞翔，因为这是你所希望的”的充满矛盾的感情。霙的深情告白，没有激烈的言语，只有一曲独奏的《利兹与青鸟》，委婉，含蓄，却能打动人心。</p>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/807cefa7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Implementing a distance vector routing algorithm</title>
      <link>https://ShinyGX.github.io/posts/5318243/</link>
      <guid>https://ShinyGX.github.io/posts/5318243/</guid>
      <pubDate>Thu, 05 Dec 2019 20:20:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;http://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab6/lab6.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Computer Networking:A Top-Down approach chapter 4 lab&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="http://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab6/lab6.html" target="_blank" rel="noopener">Computer Networking:A Top-Down approach chapter 4 lab</a></p><a id="more"></a><hr><p>这次的实验是要实现一个分布式异步距离向量算法。在实验当中提供了<code>node0,node1,node2,node3</code>来模拟3个节点的dv路由算法的寻路机制</p><h1 id="Distance-Vector-Routing-Algorithm"><a href="#Distance-Vector-Routing-Algorithm" class="headerlink" title="Distance Vector Routing Algorithm"></a>Distance Vector Routing Algorithm</h1><p>首先，我们先看看距离向量算法的思想。在这个算法当中，最核心的思想就是，当我们从节点x到节点y选一条最短的路径，那么，我们首先就要选择离节点y最近的节点z，假设我们已经知道了节点x-&gt;z的最短的路径，那么，x-&gt;y的最短路径就是x-&gt;z-&gt;y。然后，我们的问题就变成了寻找x-&gt;z的最短路径。按照这个思路递归下去，我们就可以只根据邻居节点的距离向量表就可以得知x-&gt;y的最短的距离，从而能够沿着最短的路从x-&gt;y进行行走了。</p><p>根据这个思想，我们不难得知，对于一个节点x，他只需要知道自己节点的距离向量(链路cost)，以及邻居节点的距离向量(链路cost)就可以得知整个链路的所有节点的最短距离了。</p><p>因此，这个算法是分布式的算法。他只需要从邻居得到数据，然后修改自己的数据，假如修改了自己的距离向量表就向邻居通告自己修改了，直到没有消息能够再传递为止。这个算法也是异步的，因此，他不要求所有节点都一起计算。同时他也是可以自我停止的，当所有节点都找到了最小cost的链路之后，整个网络当中就再无信息交流，从而算法也停止了。</p><p>对于dv算法，我们维护以下的信息</p><ul><li>对于每一个邻居v,从x到直接相连的邻居v的费用为<code>c(x,v)</code></li><li>对于节点x的距离向量$ D_x=[D_x(y):y\in N] $</li><li>对于节点x的每一个邻居v的距离向量都有$ D_v=[D_v(y):y\in N] $</li></ul><p>同时对于距离向量的计算方式有$D_x(y)=min_v{c(x,v) + D_v(y)}$</p><p>看上去似乎有点抽象，我们就实际出发，从代码实现来看吧。由于四个node的实现其实是基本一样的，因此这里就只以<code>node0</code>为例子</p><p>首先就是初始化距离向量表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtinit0</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">      dt0.costs[i][j] = __MAX_COST__;</span><br><span class="line"></span><br><span class="line">  dt0.costs[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dt0.costs[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dt0.costs[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">  dt0.costs[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dt0.costs[<span class="number">0</span>][i] == <span class="number">0</span> || dt0.costs[<span class="number">0</span>][i] == __MAX_COST__)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtpkt</span> <span class="title">pkt</span>;</span></span><br><span class="line">    pkt.destid = i;</span><br><span class="line">    pkt.sourceid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(pkt.mincost,dt0.costs[<span class="number">0</span>],<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">4</span>);</span><br><span class="line">    tolayer2(pkt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(TRACE &gt;= <span class="number">1</span>)</span><br><span class="line">    printdt0(&amp;dt0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有不通的路都设为最大的cost，然后，为所有邻居的cost都标记上(这个cost是题目给定的)，然后，由于自己的距离向量表得到了更改，因此，向自己的所有邻居都通告。</p><p>之后，初始化就完成了。然后是迭代的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtupdate0</span><span class="params">(rcvdpkt)</span></span></span><br><span class="line"><span class="function">  struct rtpkt *rcvdpkt</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(rcvdpkt-&gt;destid != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(dt0.costs[rcvdpkt-&gt;sourceid],rcvdpkt-&gt;mincost,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">int</span> hasChange = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dt0.costs[<span class="number">0</span>][rcvdpkt-&gt;sourceid] + dt0.costs[rcvdpkt-&gt;sourceid][i] &lt;  dt0.costs[<span class="number">0</span>][i])</span><br><span class="line">    &#123;</span><br><span class="line">      hasChange = <span class="number">1</span>;</span><br><span class="line">      dt0.costs[<span class="number">0</span>][i] = dt0.costs[<span class="number">0</span>][rcvdpkt-&gt;sourceid] + dt0.costs[rcvdpkt-&gt;sourceid][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(hasChange)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(dt0.costs[<span class="number">0</span>][i] == <span class="number">0</span> || dt0.costs[<span class="number">0</span>][i] == __MAX_COST__)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtpkt</span> <span class="title">pkt</span>;</span></span><br><span class="line">        pkt.destid = i;</span><br><span class="line">        pkt.sourceid = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(pkt.mincost,dt0.costs[<span class="number">0</span>],<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">4</span>);</span><br><span class="line">        tolayer2(pkt);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(TRACE &gt;= <span class="number">1</span>)</span><br><span class="line">    printdt0(&amp;dt0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就是我们一旦接收到邻居传来的距离向量表的通告，我们就要为我们的距离向量表更新内容了。首先，我们先保存下来邻居的信息，然后，我们试图计算从我们自己的节点到所有其他节点的费用,根据之前的公式我们可以直到，我们的思路就是，比较当前节点到目的节点与当前节点先到邻居节点再到目的节点的路线谁费用比较低，假如，先走邻居节点比直接到达的费用要低，我们就更新我们的距离向量表，并通告所有的邻居</p><p>这样一来一去，一来一去的，直到再也没有收到邻居的来信，就说明所有节点都已经收敛到最低费用的情况了。</p><p>这个算法的思想和实现都比较简单，但是会有一个问题，那就是这个算法会陷入无穷计数问题(count to infinty)。比如，节点x-&gt;y的费用从1上升到了1000，那么，在这个算法当中，就只能在两个节点之间不断向上试探才能够慢慢收敛到正确的费用上去，这样，大大的耗费了网络的资源。虽然，两个节点之间的无穷计数问题可以由毒性逆转来解决，但是多个节点的话，这个问题也依旧没有解决</p><p>现在，回到实验，我们可以看看所有的节点的距离向量表的表现形式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                via     </span><br><span class="line">   D0 |    <span class="number">1</span>     <span class="number">2</span>    <span class="number">3</span> </span><br><span class="line">  ----|-----------------</span><br><span class="line">     <span class="number">1</span>|    <span class="number">0</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">dest <span class="number">2</span>|    <span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">3</span>|    <span class="number">3</span>     <span class="number">2</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">             via   </span><br><span class="line">   D1 |    <span class="number">0</span>     <span class="number">2</span> </span><br><span class="line">  ----|-----------</span><br><span class="line">     <span class="number">0</span>|    <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">dest <span class="number">2</span>|    <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">3</span>|  <span class="number">1000</span>   <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">                via</span><br><span class="line">   D2 |    <span class="number">0</span>     <span class="number">1</span>    <span class="number">3</span> </span><br><span class="line">  ----|-----------------</span><br><span class="line">     <span class="number">0</span>|    <span class="number">0</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">dest <span class="number">1</span>|    <span class="number">1</span>     <span class="number">0</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">3</span>|    <span class="number">4</span>     <span class="number">3</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">             via     </span><br><span class="line">   D3 |    <span class="number">0</span>     <span class="number">2</span> </span><br><span class="line">  ----|-----------</span><br><span class="line">     <span class="number">0</span>|    <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">dest <span class="number">1</span>|  <span class="number">1000</span>   <span class="number">1000</span></span><br><span class="line">     <span class="number">2</span>|    <span class="number">2</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在实验当中，d1与d3不是邻居，自然是不会有其距离向量表信息保存下来的，但是，他们之间依然能够找到它们之间的最短链路<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">0</span>):<span class="number">0</span> (<span class="number">0</span>,<span class="number">1</span>):<span class="number">1</span> (<span class="number">0</span>,<span class="number">2</span>):<span class="number">2</span> (<span class="number">0</span>,<span class="number">3</span>):<span class="number">4</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>):<span class="number">1</span> (<span class="number">1</span>,<span class="number">1</span>):<span class="number">0</span> (<span class="number">1</span>,<span class="number">2</span>):<span class="number">1</span> (<span class="number">1</span>,<span class="number">3</span>):<span class="number">3</span> </span><br><span class="line">(<span class="number">2</span>,<span class="number">0</span>):<span class="number">2</span> (<span class="number">2</span>,<span class="number">1</span>):<span class="number">1</span> (<span class="number">2</span>,<span class="number">2</span>):<span class="number">0</span> (<span class="number">2</span>,<span class="number">3</span>):<span class="number">2</span> </span><br><span class="line">(<span class="number">3</span>,<span class="number">0</span>):<span class="number">4</span> (<span class="number">3</span>,<span class="number">1</span>):<span class="number">3</span> (<span class="number">3</span>,<span class="number">2</span>):<span class="number">2</span> (<span class="number">3</span>,<span class="number">3</span>):<span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://ShinyGX.github.io/posts/5318243/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
